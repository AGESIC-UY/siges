package com.sofis.business.ejbs;

import com.sofis.business.constantes.ConfiguracionConstantes;
import com.sofis.business.properties.LabelsEJB;
import com.sofis.business.utils.MailsTemplateUtils;
import com.sofis.data.daos.NotificacionEnvioDAO;
import com.sofis.entities.constantes.ConstanteApp;
import com.sofis.entities.constantes.ConstantesEstandares;
import com.sofis.entities.constantes.ConstantesNotificaciones;
import com.sofis.entities.data.Adquisicion;
import com.sofis.entities.data.Configuracion;
import com.sofis.entities.data.Entregables;
import com.sofis.entities.data.Estados;
import com.sofis.entities.data.NotificacionEnvio;
import com.sofis.entities.data.NotificacionInstancia;
import com.sofis.entities.data.Organismos;
import com.sofis.entities.data.Pagos;
import com.sofis.entities.data.Presupuesto;
import com.sofis.entities.data.Proyectos;
import com.sofis.entities.data.SsRol;
import com.sofis.entities.data.SsUsuario;
import com.sofis.entities.utils.SsUsuariosUtils;
import com.sofis.exceptions.MailException;
import com.sofis.generico.utils.generalutils.CollectionsUtils;
import com.sofis.generico.utils.generalutils.DatesUtils;
import com.sofis.generico.utils.generalutils.StringsUtils;
import com.sofis.persistence.dao.exceptions.DAOGeneralException;
import com.sofis.sofisform.to.CriteriaTO;
import com.sofis.sofisform.to.MatchCriteriaTO;
import com.sofis.utils.CriteriaTOUtils;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.ejb.LocalBean;
import javax.ejb.Lock;
import javax.ejb.LockType;
import javax.ejb.Schedule;
import javax.ejb.Stateless;
import javax.inject.Inject;
import javax.inject.Named;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

/**
 *
 * @author Usuario
 */
@Named
@Stateless(name = "notificacionEnvioBean")
@LocalBean
public class NotificacionEnvioBean {

    @PersistenceContext(unitName = ConstanteApp.PERSISTENCE_CONTEXT_UNIT_NAME)
    private EntityManager em;
    private static final Logger logger = Logger.getLogger(ConstanteApp.LOGGER_NAME);
    private static final String HORA_EJECUCION = "02";
    private static final String MINUTOS_EJECUCION = "30";
    public static final String NOMBRE_PROYECTO = "NOMBRE_PROYECTO";
    @Inject
    private DatosUsuario du;
    @Inject
    private NotificacionInstanciaBean notificacionInstanciaBean;
    @Inject
    private OrganismoBean organismoBean;
    @Inject
    private ProyectosBean proyectosBean;
    @Inject
    private RiesgosBean riesgosBean;
    @Inject
    private ConfiguracionBean configuracionBean;
    @Inject
    private MailBean mailBean;
    @Inject
    private SsUsuarioBean ssUsuarioBean;
    @Inject
    private EstadosBean estadosBean;
    @Inject
    private PresupuestoBean presupuestoBean;
    @Inject
    private PagosBean pagosBean;

    @Schedule(hour = HORA_EJECUCION, minute = MINUTOS_EJECUCION)
    public void enviarNotificaciones() {
        List<Organismos> orgList = organismoBean.obtenerTodos();

        for (Organismos org : orgList) {
            Integer orgPk = org.getOrgPk();

            Configuracion cnfEnvioNot = configuracionBean.obtenerCnfPorCodigoYOrg(ConfiguracionConstantes.ENVIO_NOTIFICACIONES, orgPk);
            boolean enviar = Boolean.parseBoolean(cnfEnvioNot.getCnfValor());

            if (enviar) {
                final List<Integer> idsProy = proyectosBean.obtenerIdsProyPorOrg(orgPk);
                System.out.println("*** Notificaciones para el org:" + org.getOrgNombre());
                long t = new Date().getTime();

                Map<String, String> confMap = new HashMap<>();
                Configuracion cConfAmarillo = configuracionBean.obtenerCnfPorCodigoYOrg(ConfiguracionConstantes.RIESGO_INDICE_LIMITE_AMARILLO, orgPk);
                confMap.put(ConfiguracionConstantes.RIESGO_INDICE_LIMITE_AMARILLO, cConfAmarillo.getCnfValor());
                Configuracion cConfRojo = configuracionBean.obtenerCnfPorCodigoYOrg(ConfiguracionConstantes.RIESGO_INDICE_LIMITE_ROJO, orgPk);
                confMap.put(ConfiguracionConstantes.RIESGO_INDICE_LIMITE_ROJO, cConfRojo.getCnfValor());

                for (Integer proyPk : idsProy) {
                    Proyectos proy = proyectosBean.obtenerProyPorId(proyPk);

                    enviarNotificaciones(proy, orgPk, confMap);
                }
                System.out.println("Tiempo total para enviar notificaciones para el org " + org.getOrgNombre() + ": " + (new Date().getTime() - t));
            }
        }
    }

    private void enviarNotificaciones(Proyectos proy, Integer orgPk, Map<String, String> confMap) {
        if (proy != null
                && proy.isActivo()
                && !proy.isEstadoPendientes()
                && !proy.isEstado(Estados.ESTADOS.FINALIZADO.estado_id)) {

            riesgosDesactualizados(proy, orgPk, confMap);
            tiempoEnInicio(proy, orgPk);
            tiempoEnPlanificacion(proy, orgPk);
            actualizacionProyAmarillo(proy, orgPk);
            actualizacionProyRojo(proy, orgPk);
            fechaPagoVencida(proy, orgPk);
            devengadoUltimosDiasMes(proy, orgPk);
            entPagoPrimerAviso(proy, orgPk);
            entPagoSegundoAviso(proy, orgPk);
            fechaProyectadaFinAnio(proy, orgPk);
            entregableVencido(proy, orgPk);
        }
    }

    /**
     * Riesgos 1: Riesgos desactualizados. Se debe disparar cuando se pasa a
     * amarillo el semáforo de actualización de riesgos (timer)
     *
     * @param proy
     * @param orgPk
     * @param confMap
     */
    private void riesgosDesactualizados(Proyectos proy, Integer orgPk, Map<String, String> confMap) {
        String riesgoColor = riesgosBean.obtenerExposicionRiesgoColor(proy.getProyIndices().getProyindRiesgoExpo(), orgPk, confMap);

        if (riesgoColor.equals(ConstantesEstandares.SEMAFORO_AMARILLO)
                || riesgoColor.equals(ConstantesEstandares.SEMAFORO_ROJO)) {
            enviarNotificacion(ConstantesNotificaciones.NOT_COD_RIESGOS_1, proy, orgPk);
        } else if (riesgoColor.equals(ConstantesEstandares.SEMAFORO_VERDE)) {
            notificacionSuperada(ConstantesNotificaciones.NOT_COD_RIESGOS_1, proy.getProyPk());
        }
    }

    /**
     * Riesgos 2: Nuevo riesgo alto. Se debe disparar cuando se registra un
     * nuevo riesgo y este cae en la zona roja o cuando a un riesgo existente se
     * le modifica la probabilidad y/o impacto y pasa a estar en la zona
     * roja(evento)
     */
    public void nuevoRiesgoAlto(Proyectos proy, Integer orgPk, Map<String, String> confMap) {
        String riesgoColor = riesgosBean.obtenerExposicionRiesgoColor(proy.getProyIndices().getProyindRiesgoExpo(), orgPk, confMap);

        if (riesgoColor.equals(ConstantesEstandares.SEMAFORO_ROJO)) {
            enviarNotificacion(ConstantesNotificaciones.NOT_COD_RIESGOS_2, proy, orgPk);
        } else if (!riesgoColor.equals(ConstantesEstandares.SEMAFORO_ROJO)) {
            notificacionSuperada(ConstantesNotificaciones.NOT_COD_RIESGOS_2, proy.getProyPk());
        }
    }

    /**
     * Inicio: Demasiado tiempo en Inicio. Se debe disparar cuando pasa a estar
     * rojo el semáforo que indica que hace mucho tiempo que está en inicio
     * (timer)
     */
    private void tiempoEnInicio(Proyectos proy, Integer orgPk) {
        String estColor = estadosBean.obtenerEstadoColor(proy.getProyEstFk(), proy.getProyFechaEstadoAct(), proy.getProySemaforoAmarillo(), proy.getProySemaforoRojo());

        if (estColor.equals(ConstantesEstandares.SEMAFORO_ROJO)) {
            enviarNotificacion(ConstantesNotificaciones.NOT_COD_INICIO, proy, orgPk);
        } else if (!estColor.equals(ConstantesEstandares.SEMAFORO_ROJO)) {
            notificacionSuperada(ConstantesNotificaciones.NOT_COD_INICIO, proy.getProyPk());
        }
    }

    /**
     * Planificación: Demasiado tiempo en Planificación. Se debe disparar cuando
     * pasa a estar en rojo el semáforo que indica que hace mucho tiempo que
     * está en planificación (timer)
     */
    private void tiempoEnPlanificacion(Proyectos proy, Integer orgPk) {
        String estColor = estadosBean.obtenerEstadoColor(proy.getProyEstFk(), proy.getProyFechaEstadoAct(), proy.getProySemaforoAmarillo(), proy.getProySemaforoRojo());

        if (estColor.equals(ConstantesEstandares.SEMAFORO_ROJO)) {
            enviarNotificacion(ConstantesNotificaciones.NOT_COD_PLANIFICACION, proy, orgPk);
        } else if (!estColor.equals(ConstantesEstandares.SEMAFORO_ROJO)) {
            notificacionSuperada(ConstantesNotificaciones.NOT_COD_PLANIFICACION, proy.getProyPk());
        }
    }

    /**
     * Actualización 1: Se debe disparar cuando el semáforo de actualización del
     * proyecto pasa a estar en amarillo(timer)
     */
    private void actualizacionProyAmarillo(Proyectos proy, Integer orgPk) {
        String actColor = proyectosBean.obtenerUltimaActualizacionColor(proy.getProyEstFk(), proy.getProyFechaAct(), proy.getProySemaforoAmarillo(), proy.getProySemaforoRojo());

        if (actColor.equals(ConstantesEstandares.SEMAFORO_AMARILLO)) {
            enviarNotificacion(ConstantesNotificaciones.NOT_COD_ACTUALIZACION_1, proy, orgPk);
        } else if (!actColor.equals(ConstantesEstandares.SEMAFORO_AMARILLO)) {
            notificacionSuperada(ConstantesNotificaciones.NOT_COD_ACTUALIZACION_1, proy.getProyPk());
        }
    }

    /**
     * Actualización 2: Se debe disparar cuando el semáforo de actualización del
     * proyecto pasa a estar en rojo (timer)
     */
    private void actualizacionProyRojo(Proyectos proy, Integer orgPk) {
        String actColor = proyectosBean.obtenerUltimaActualizacionColor(proy.getProyEstFk(), proy.getProyFechaAct(), proy.getProySemaforoAmarillo(), proy.getProySemaforoRojo());

        if (actColor.equals(ConstantesEstandares.SEMAFORO_ROJO)) {
            enviarNotificacion(ConstantesNotificaciones.NOT_COD_ACTUALIZACION_2, proy, orgPk);
        } else if (!actColor.equals(ConstantesEstandares.SEMAFORO_ROJO)) {
            notificacionSuperada(ConstantesNotificaciones.NOT_COD_ACTUALIZACION_2, proy.getProyPk());
        }
    }

    /**
     * Presupuesto 1: Dada la fecha de pago proyectada (real), se debe disparar
     * cuando esa fecha se venció y no ha sido confirmada la factura (las
     * opciones son confirmarla o cambiar la fecha y/o el importe) (timer)
     */
    private void fechaPagoVencida(Proyectos proy, Integer orgPk) {
        Presupuesto pre = presupuestoBean.obtenerPresupuestoPorProy(proy.getProyPk());
        if (pre != null && pre.getAdquisicionSet() != null) {
            for (Adquisicion adq : pre.getAdquisicionSet()) {
                if (adq.getPagosSet() != null) {
                    for (Pagos pago : adq.getPagosSet()) {
                        if (!pago.isPagConfirmado()
                                && DatesUtils.esMayor(new Date(), pago.getPagFechaReal())) {
                            enviarNotificacion(ConstantesNotificaciones.NOT_COD_PRESUPUESTO_1, proy, orgPk);
                        }
                    }
                }
            }
        }
    }

    /**
     * Presupuesto 2: Devengado. Durante los últimos 5 días hábiles del mes,
     * solamente para los proyectos que tienen cargado devengado es necesario
     * mandar un aviso al para que actualicen el devengado dado que cuando
     * comience el siguiente mes no se podrá tocar el actual (timer con
     * repetición) - Este lo vemos bien luego.
     */
    private void devengadoUltimosDiasMes(Proyectos proy, Integer orgPk) {
//        ConstantesNotificaciones.NOT_COD_PRESUPUESTO_2;
        //TODO: Realizarlo luego de hacer los cambios en presupuesto.
    }

    /**
     * Presupuesto 3: Cuando un entregable está al 100% y tiene un pago asociado
     * cuya factura no está confirmada. A los 5 días de suceder esto se podrá
     * mandar una notificación para que consigan la factura (timer)
     */
    private void entPagoPrimerAviso(Proyectos proy, Integer orgPk) {
        List<Pagos> listPagos = pagosBean.obtenerPagosDiasVenc(proy.getProyPk(), 5);
        for (Pagos pagos : listPagos) {
            enviarNotificacion(ConstantesNotificaciones.NOT_COD_PRESUPUESTO_3, proy, orgPk);
        }
    }

    /**
     * Presupuesto 4: Cuando un entregable está al 100% y tiene un pago asociado
     * cuya factura no está confirmada. A los 10 días de suceder esto se podrá
     * mandar una notificación para que consigan la factura (timer) (como la
     * anterior pero con más días)
     */
    private void entPagoSegundoAviso(Proyectos proy, Integer orgPk) {
        List<Pagos> listPagos = pagosBean.obtenerPagosDiasVenc(proy.getProyPk(), 10);
        for (Pagos pagos : listPagos) {
            enviarNotificacion(ConstantesNotificaciones.NOT_COD_PRESUPUESTO_4, proy, orgPk);
        }
    }

    /**
     * Presupuesto 5: Cuando el gerente de proyecto indica que la nueva fecha
     * proyectada de la confirmación de una factura es durante la última
     * quincena del año o al año siguiente se debe disponer la posibilidad de
     * mandar una notificación (evento)
     */
    private void fechaProyectadaFinAnio(Proyectos proy, Integer orgPk) {
//        ConstantesNotificaciones.NOT_COD_PRESUPUESTO_5;
        //TODO: Realizarlo luego de hacer los cambios en presupuesto.
    }

    /**
     * Cronograma 1: Cuando un entregable no está al 100% de avance y tiene
     * fecha de fin anterior al día de hoy se podrá mandar una notificación.
     * Esto se daría solamente en caso que el proyecto está desactualizado dado
     * que o bien el entregable está finalizado o debe finalizar con una fecha
     * mayor o igual a la actual (timer)
     */
    private void entregableVencido(Proyectos proy, Integer orgPk) {
        String actColor = proyectosBean.obtenerUltimaActualizacionColor(proy.getProyEstFk(), proy.getProyFechaAct(), proy.getProySemaforoAmarillo(), proy.getProySemaforoRojo());

        if (actColor.equals(ConstantesEstandares.SEMAFORO_AMARILLO)
                || actColor.equals(ConstantesEstandares.SEMAFORO_ROJO)) {
            Date hoy = new Date();
            boolean enviar = false;
            for (Entregables ent : proy.getProyCroFk().getEntregablesSet()) {
                if (ent.getEntProgreso() < 100
                        && DatesUtils.esMayor(hoy, ent.getEntFinDate())) {
                    enviar = true;
                    break;
                }
            }

            if (enviar) {
                enviarNotificacion(ConstantesNotificaciones.NOT_COD_CRONOGRAMA_1, proy, orgPk);
            } else {
                notificacionSuperada(ConstantesNotificaciones.NOT_COD_CRONOGRAMA_1, proy.getProyPk());
            }
        }
    }

    /**
     * Envía la notificación según el código si es que aún no ha sido enviada.
     *
     * @param codNot
     * @param proy
     * @param orgPk
     */
    private void enviarNotificacion(String codNot, Proyectos proy, Integer orgPk) {
        if (!fueNotificado(codNot, orgPk)) {
            NotificacionInstancia ni = notificacionInstanciaBean.obtenerNotificacionInstPorCod(codNot, proy.getProyPk(), orgPk);
            String subject = LabelsEJB.getValue("notif_envio_subjet");

            List<SsUsuario> usuariosDest = new ArrayList<>();
            if (ni.getNotinstGerenteAdjunto()) {
                usuariosDest.add(proy.getProyUsrGerenteFk());
                usuariosDest.add(proy.getProyUsrAdjuntoFk());
            }
            if (ni.getNotinstSponsor()) {
                usuariosDest.add(proy.getProyUsrSponsorFk());
            }
            if (ni.getNotinstPmof()) {
                usuariosDest.add(proy.getProyUsrPmofedFk());
            }
            if (ni.getNotinstPmot()) {
                usuariosDest.addAll(ssUsuarioBean.obtenerUsuariosPorRol(SsRol.ROLES.PMO_TRANSVERSAL.rol_id, orgPk));
            }
            String[] destinatarios = SsUsuariosUtils.arrayMailsUsuarios(usuariosDest);

            Map<String, String> valores = new HashMap<>();
            valores.put(NOMBRE_PROYECTO, proy.getProyPk() + " - '" + proy.getProyNombre() + "'");
            String mensaje = MailsTemplateUtils.instanciarConHashMap(ni.getNotinstNotFk().getNotMsg(), valores);

            final String subjectThread = subject;
            final String[] destinatariosThread = destinatarios;
            final String mensajeThread = mensaje;
            final Integer orgPkThread = orgPk;
            final String codNotThread = codNot;
            final Proyectos proyThread = proy;

            Thread t = new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        mailBean.enviarMail(subjectThread, null, null, null, destinatariosThread, mensajeThread, orgPkThread);
                        agregarNotificacionEnvio(codNotThread, proyThread.getProyPk());
                    } catch (MailException me) {
                        for (String error : me.getErrores()) {
                            logger.log(Level.WARNING, error);
                        }
                    }
                }
            });
            t.start();
        }
    }

    /**
     * Consulta si la notificación para dicho código y proyecto ya fue enviada.
     *
     * @param codNot
     * @param proyPk
     * @return boolean true si fue enviada.
     */
    public boolean fueNotificado(String codNot, Integer proyPk) {
        NotificacionEnvioDAO dao = new NotificacionEnvioDAO(em);

        CriteriaTO criteriaCod = CriteriaTOUtils.createMatchCriteriaTO(MatchCriteriaTO.types.EQUALS, "notenvNotCod", codNot);
        CriteriaTO criteriaProy = CriteriaTOUtils.createMatchCriteriaTO(MatchCriteriaTO.types.EQUALS, "notenvProyFk", proyPk);
        CriteriaTO criteria = CriteriaTOUtils.createANDTO(criteriaCod, criteriaProy);

        List<NotificacionEnvio> neList = null;
        try {
            neList = dao.findEntityByCriteria(NotificacionEnvio.class, criteria, new String[]{}, new boolean[]{}, null, null);
        } catch (DAOGeneralException ex) {
            Logger.getLogger(NotificacionEnvioBean.class.getName()).log(Level.SEVERE, null, ex);
        }

        if (CollectionsUtils.isNotEmpty(neList)) {
            return true;
        }
        return false;
    }

    private void notificacionSuperada(String cod, Integer proyPk) {
        if (!StringsUtils.isEmpty(cod) && proyPk != null) {
            NotificacionEnvioDAO dao = new NotificacionEnvioDAO(em);
            dao.superarNotEnviada(cod, proyPk);
        }
    }

    private void agregarNotificacionEnvio(String cod, Integer proyPk) {
        NotificacionEnvioDAO dao = new NotificacionEnvioDAO(em);
        try {
            dao.create(new NotificacionEnvio(null, new Date(), proyPk, cod));
        } catch (DAOGeneralException ex) {
            logger.log(Level.SEVERE, "No se pudo agregar la notificación enviada para el proy: " + proyPk + " y cod: " + cod);
            logger.log(Level.SEVERE, null, ex);

        }
    }

    public void superarFechaPagoVencida(Integer proyPk) {
        notificacionSuperada(ConstantesNotificaciones.NOT_COD_PRESUPUESTO_1, proyPk);
    }
}